# BrowserGateway 开发者测试设计文档

## 1. 文档概述

### 1.1 文档目的
本文档基于当前已实现的测试用例，整理并说明BrowserGateway组件的单元测试设计方法、测试覆盖范围、测试用例设计思路等内容，为开发者提供测试参考和指导。

### 1.2 适用范围
- 测试框架：JUnit 5 + Mockito
- 测试方法：决策表（Decision Table, DT）方法
- 测试类型：单元测试
- 测试语言：Java 21


## 2. 测试方法

### 2.1 决策表（Decision Table）方法
本项目所有测试用例均采用**决策表（DT）方法**进行设计，这是一种系统化的测试设计技术，特别适用于具有多个输入条件和复杂业务逻辑的场景。

#### 2.1.1 决策表方法优势
- **系统化覆盖**：通过条件组合，系统化地覆盖各种输入场景
- **易于维护**：测试用例结构清晰，易于理解和维护
- **减少遗漏**：通过条件矩阵，减少测试场景遗漏
- **参数化测试**：结合JUnit 5的参数化测试，实现高效的测试执行

#### 2.1.2 决策表结构
每个决策表包含：
- **条件（Conditions）**：影响系统行为的输入条件
- **动作（Actions）**：系统在特定条件下的预期行为
- **规则（Rules）**：条件组合与对应动作的映射关系

### 2.2 测试框架

#### 2.2.1 JUnit 5
- **版本**：5.11.0
- **主要特性**：
  - `@ParameterizedTest`：参数化测试，支持决策表数据驱动
  - `@MethodSource`：从静态方法获取测试数据
  - `@DisplayName`：提供清晰的测试显示名称
  - `@ExtendWith`：扩展支持（如MockitoExtension）

#### 2.2.2 Mockito
- **版本**：4.5.1
- **主要用途**：
  - Mock依赖服务，实现单元测试隔离
  - 验证方法调用次数和参数
  - 模拟异常场景

## 3. 测试覆盖范围

### 3.1 测试模块统计

| 模块 | 测试类 | 测试方法数 | 决策表规则数 |
|------|--------|-----------|------------|
| API层 | ExtensionManageApiTest | 3 | 10 |
| API层 | ChromeApiTest | 3 | 18 |
| Service层 | ChromeSetImplTest | 5 | 11 |
| 工具类 | UserIdUtilTest | 5 | 20 |
| 编解码 | TlvCodecTest | 5 | 12 |
| 状态机 | BrowserStateMachineTest | 5 | 25 |
| **总计** | **6** | **26** | **96** |

### 3.2 测试覆盖的功能模块

1. **扩展管理模块**
   - 扩展加载接口
   - 插件信息查询接口

2. **浏览器管理模块**
   - 预开浏览器接口
   - 删除用户数据接口
   - 浏览器实例创建
   - 浏览器实例删除

3. **工具类模块**
   - 用户ID生成与验证
   - TLV编解码
   - 浏览器状态机

## 4. 各模块测试设计详情

### 4.1 ExtensionManageApiTest（扩展管理API测试）

#### 4.1.1 测试目标
测试扩展管理API接口的参数验证、业务逻辑和异常处理。

#### 4.1.2 决策表：加载扩展接口

**条件（Conditions）**：
- C1: 请求参数是否为null
- C2: name是否为空
- C3: version是否为空
- C4: bucketName是否为空
- C5: extensionFilePath是否为空
- C6: extensionFilePath是否以.jar结尾
- C7: 插件加载是否成功

**动作（Actions）**：
- A1: 返回码
- A2: 返回消息
- A3: 是否调用chromeSet.deleteAll
- A4: 是否调用pluginManage.loadExtension

**规则（Rules）**：
- R1: 请求参数为null → 返回400错误
- R2: name为空 → 返回400错误
- R3: version为空 → 返回400错误
- R4: bucketName为空 → 返回400错误
- R5: extensionFilePath为空 → 返回400错误
- R6: extensionFilePath不以.jar结尾 → 返回400错误
- R7: 所有参数有效，加载成功 → 返回200成功
- R8: 所有参数有效，加载失败 → 返回1002错误

#### 4.1.3 决策表：获取插件信息接口

**条件（Conditions）**：
- C1: 插件是否已加载

**动作（Actions）**：
- A1: 返回码
- A2: 返回消息
- A3: 是否返回插件信息

**规则（Rules）**：
- R1: 插件已加载 → 返回200和插件信息
- R2: 插件未加载 → 返回1005错误

#### 4.1.4 异常场景测试
- 插件管理服务异常
- 获取插件信息异常

### 4.2 ChromeApiTest（Chrome API测试）

#### 4.2.1 测试目标
测试Chrome浏览器API接口的参数验证、业务逻辑和异常处理。

#### 4.2.2 决策表：预开浏览器接口

**条件（Conditions）**：
- C1: 请求参数是否为null
- C2: IMEI是否为空
- C3: IMSI是否为空
- C4: 屏幕宽度是否有效（>0）
- C5: 屏幕高度是否有效（>0）
- C6: 浏览器实例是否已存在

**动作（Actions）**：
- A1: 返回码
- A2: 返回消息
- A3: 是否调用remoteService.createChrome

**规则（Rules）**：
- R1: 请求参数为null → 返回400错误
- R2: IMEI和IMSI同时为空 → 返回400错误
- R3: IMEI有效，IMSI为空，实例不存在 → 成功创建
- R4: IMEI为空，IMSI有效，实例不存在 → 成功创建
- R5: IMEI和IMSI都有效，实例已存在 → 跳过创建
- R6-R9: 屏幕宽度/高度无效 → 返回400错误
- R10: 所有参数有效，实例不存在 → 成功创建

#### 4.2.3 决策表：删除用户数据接口

**条件（Conditions）**：
- C1: 请求参数是否为null
- C2: IMEI是否为空
- C3: IMSI是否为空
- C4: 浏览器实例是否存在
- C5: UserDataManager是否可用

**动作（Actions）**：
- A1: 返回码
- A2: 是否调用chromeSet.delete
- A3: 是否调用userDataManager.deleteUserData

**规则（Rules）**：
- R1: 请求参数为null → 返回400错误
- R2: IMEI和IMSI同时为空 → 返回400错误
- R3: 参数有效，实例不存在，UserDataManager可用 → 幂等返回成功
- R4: 参数有效，实例不存在，UserDataManager不可用 → 幂等返回成功
- R5: 参数有效，实例存在，UserDataManager可用 → 删除成功
- R6: 参数有效，实例存在，UserDataManager不可用 → 删除成功（跳过数据删除）
- R7-R8: IMEI或IMSI单独有效 → 成功删除

#### 4.2.4 异常场景测试
- 远程服务异常
- 数据删除失败（容错设计）

### 4.3 ChromeSetImplTest（ChromeSet实现测试）

#### 4.3.1 测试目标
测试浏览器实例管理的核心业务逻辑，包括创建、删除、查询等操作。

#### 4.3.2 决策表：创建浏览器实例

**条件（Conditions）**：
- C1: 实例是否已存在
- C2: UserDataManager是否可用
- C3: 用户数据下载是否成功
- C4: PluginManage是否为PluginManageImpl实例
- C5: MuenDriver创建是否成功

**动作（Actions）**：
- A1: 是否删除旧实例
- A2: 是否下载用户数据
- A3: 是否创建MuenDriver
- A4: 最终状态

**规则（Rules）**：
- R1: 实例不存在，UserDataManager可用，下载成功，PluginManageImpl，MuenDriver创建成功 → 成功创建（READY）
- R2: 实例已存在，所有条件满足 → 删除旧实例后创建（READY）
- R3: 实例不存在，UserDataManager不可用 → 成功创建（跳过数据下载）
- R4: 实例不存在，UserDataManager可用，下载失败 → 成功创建（容错）
- R5: 实例不存在，不是PluginManageImpl → 成功创建（跳过MuenDriver）

#### 4.3.3 决策表：删除浏览器实例

**条件（Conditions）**：
- C1: 实例是否存在
- C2: ControlClientSet是否可用
- C3: MediaClientSet是否可用
- C4: UserDataManager是否可用
- C5: 数据上传是否成功

**动作（Actions）**：
- A1: 是否调用removeClient（控制流）
- A2: 是否调用removeClient（媒体流）
- A3: 是否上传用户数据
- A4: 是否调用closeInstance
- A5: 实例是否从map中移除

**规则（Rules）**：
- R1: 实例不存在 → 不执行任何操作
- R2: 实例存在，所有服务可用，上传成功 → 完整删除流程
- R3: 实例存在，ControlClientSet不可用 → 跳过控制流清理
- R4: 实例存在，MediaClientSet不可用 → 跳过媒体流清理
- R5: 实例存在，UserDataManager不可用 → 跳过数据上传
- R6: 实例存在，UserDataManager可用，上传失败 → 继续删除（容错）

#### 4.3.4 其他测试
- 获取浏览器实例
- 删除所有实例
- 获取所有用户

### 4.4 TlvCodecTest（TLV编解码测试）

#### 4.4.1 测试目标
测试TLV（Type-Length-Value）消息编解码的正确性和完整性。

#### 4.4.2 决策表：TLV编组测试

**条件（Conditions）**：
- C1: Message是否为null
- C2: Message类型是否有效
- C3: Message字段是否完整

**动作（Actions）**：
- A1: 是否抛出异常
- A2: TlvMessage是否创建成功
- A3: TlvMessage类型是否正确

**规则（Rules）**：
- R1: Message为null → 抛出异常
- R2-R4: Message类型为LOGIN/HEARTBEATS/LOGOUT，字段完整 → 成功编组
- R5: Message字段为空 → 成功编组（空值）

#### 4.4.3 决策表：TLV解码测试

**条件（Conditions）**：
- C1: TlvMessage是否为null
- C2: TlvMessage类型是否有效
- C3: TlvMessage值是否为空

**动作（Actions）**：
- A1: 是否抛出异常
- A2: Message是否创建成功
- A3: Message类型是否正确

**规则（Rules）**：
- R1: TlvMessage为null → 抛出异常
- R2-R3: TlvMessage类型为LOGIN/HEARTBEATS，值有效 → 成功解码
- R4: TlvMessage值为空 → 成功解码（空字段）

#### 4.4.4 决策表：编解码往返测试

**条件（Conditions）**：
- C1: 原始Message类型
- C2: 原始Message字段

**动作（Actions）**：
- A1: 编解码后Message是否与原始一致

**规则（Rules）**：
- R1-R3: LOGIN/HEARTBEATS/LOGOUT消息，字段完整 → 往返一致
- R4: 预开浏览器消息（audType和token为空） → 往返一致

#### 4.4.5 其他测试
- 字节序编组测试（大端序/小端序）
- TLV格式设置测试（JSON/BINARY）

### 4.5 UserIdUtilTest（用户ID工具测试）

#### 4.5.1 测试目标
测试用户ID生成和验证工具的正确性、幂等性和唯一性。

#### 4.5.2 决策表：生成用户ID测试

**条件（Conditions）**：
- C1: IMEI是否为空
- C2: IMSI是否为空
- C3: IMEI是否包含空格
- C4: IMSI是否包含空格

**动作（Actions）**：
- A1: 是否抛出异常
- A2: 生成的用户ID格式是否正确（32位MD5）
- A3: 相同输入是否生成相同ID

**规则（Rules）**：
- R1-R2: IMEI和IMSI都为空/null → 抛出异常
- R3-R6: IMEI或IMSI至少一个有效 → 成功生成
- R7: IMEI和IMSI都有效 → 成功生成
- R8-R10: IMEI/IMSI包含空格 → 成功生成（自动trim）

#### 4.5.3 决策表：验证用户ID格式测试

**条件（Conditions）**：
- C1: 用户ID是否为null
- C2: 用户ID是否为空字符串
- C3: 用户ID长度是否为32位
- C4: 用户ID是否只包含十六进制字符

**动作（Actions）**：
- A1: 验证结果

**规则（Rules）**：
- R1-R3: null/空字符串/空白字符串 → false
- R4: 有效用户ID → true
- R5-R6: 长度不足/超过32位 → false
- R7-R9: 包含非十六进制字符/大写字母/特殊字符 → false
- R10: 全为数字但长度正确 → true

#### 4.5.4 其他测试
- 用户ID生成幂等性测试
- 不同输入生成不同ID测试
- 空格处理测试
- 边界值测试（只有IMEI/只有IMSI）

### 4.6 BrowserStateMachineTest（浏览器状态机测试）

#### 4.6.1 测试目标
测试浏览器状态机的状态转换规则、合法性和异常处理。

#### 4.6.2 决策表：状态转换验证测试

**条件（Conditions）**：
- C1: 当前状态
- C2: 目标状态

**动作（Actions）**：
- A1: 是否可以转换

**规则（Rules）**：
- R1-R2: null状态 → false
- R3: 相同状态 → true（幂等）
- R4: INITIALIZING → CREATING → true
- R5: INITIALIZING → READY → false（非法转换）
- R6: CREATING → READY → true
- R7: READY → CONNECTING → true
- R8: READY → CLOSING → true
- R9: CONNECTING → CONNECTED → true
- R10: CONNECTED → RUNNING → true
- R11: RUNNING → CLOSING → true
- R12: CLOSING → CLOSED → true
- R13: CLOSED → READY → true（支持重启）
- R14: OPEN_ERROR → CLOSING → true
- R15: NETWORK_ERROR → READY → true（错误状态可以重试）
- R16: MEMORY_ERROR → CLOSED → true
- R17: MEMORY_ERROR → READY → false（内存错误不能重试）
- R18: READY → RUNNING → false（非法转换，需要先CONNECTING）

#### 4.6.3 决策表：状态转换执行测试

**条件（Conditions）**：
- C1: 当前状态
- C2: 目标状态
- C3: 转换是否合法

**动作（Actions）**：
- A1: 是否抛出异常
- A2: 状态是否更新

**规则（Rules）**：
- R1-R4: 合法转换 → 成功，状态更新
- R5-R6: 非法转换 → 抛出异常，状态不变
- R7: 相同状态转换（幂等） → 成功，状态不变

#### 4.6.4 其他测试
- userChrome为null的异常场景
- 状态为null的异常场景（自动设置为INITIALIZING）
- 状态转换历史记录
- 完整状态转换路径测试

## 5. 测试用例设计原则

### 5.1 参数验证测试
- **空值测试**：null、空字符串、空白字符串
- **边界值测试**：最小值、最大值、临界值
- **格式验证**：文件扩展名、ID格式、数据类型

### 5.2 业务逻辑测试
- **正常流程**：所有条件满足时的正常执行路径
- **异常流程**：各种异常情况的处理
- **容错设计**：部分依赖不可用时的降级处理

### 5.3 幂等性测试
- **重复操作**：相同输入多次执行应产生相同结果
- **状态一致性**：相同状态转换的幂等性

### 5.4 异常场景测试
- **依赖服务异常**：模拟依赖服务抛出异常
- **参数异常**：非法参数的处理
- **状态异常**：非法状态转换的处理

## 6. 测试执行说明

### 6.1 运行单个测试类
```bash
mvn test -Dtest=ExtensionManageApiTest
```

### 6.2 运行所有测试
```bash
mvn test
```

### 6.3 生成测试报告
```bash
mvn surefire-report:report
```

### 6.4 测试覆盖率
建议使用JaCoCo插件生成代码覆盖率报告：
```bash
mvn clean test jacoco:report
```

## 7. 测试数据管理

### 7.1 测试常量
所有测试类都定义了测试常量，便于统一管理和维护：
- `TEST_PLUGIN_NAME`：测试插件名称
- `TEST_VERSION`：测试版本号
- `TEST_IMEI`：测试IMEI
- `TEST_IMSI`：测试IMSI
- `TEST_USER_ID`：测试用户ID

### 7.2 辅助方法
每个测试类都提供了辅助方法用于创建测试对象：
- `createLoadRequest()`：创建加载扩展请求
- `createRequest()`：创建初始化浏览器请求
- `createMessage()`：创建TLV消息
- `createPluginActive()`：创建插件激活对象

## 8. Mock策略

### 8.1 依赖隔离
使用`@Mock`注解Mock所有外部依赖：
- 服务接口（IPluginManage、IChromeSet、IRemote等）
- 工具类（UserDataManager、ControlClientSet、MediaClientSet等）

### 8.2 Mock行为设置
- **正常场景**：使用`when().thenReturn()`设置正常返回值
- **异常场景**：使用`when().thenThrow()`模拟异常
- **验证调用**：使用`verify()`验证方法调用次数和参数

### 8.3 反射工具
使用`ReflectionTestUtils`设置私有字段，用于测试内部状态：
- 设置workspace路径
- 设置服务实例
- 设置内部Map状态

## 9. 测试质量指标

### 9.1 覆盖率目标
- **语句覆盖率**：≥ 80%
- **分支覆盖率**：≥ 75%
- **方法覆盖率**：≥ 85%

### 9.2 测试用例质量
- **可读性**：测试方法名称清晰，使用`@DisplayName`提供描述
- **独立性**：每个测试用例独立，不依赖其他测试的执行顺序
- **可维护性**：使用决策表方法，测试数据集中管理
- **可重复性**：测试结果可重复，不依赖外部环境

## 11. 附录

### 11.1 测试类文件清单
- `src/test/java/com/huawei/browsergateway/api/ExtensionManageApiTest.java`
- `src/test/java/com/huawei/browsergateway/api/ChromeApiTest.java`
- `src/test/java/com/huawei/browsergateway/service/impl/ChromeSetImplTest.java`
- `src/test/java/com/huawei/browsergateway/tcpserver/common/TlvCodecTest.java`
- `src/test/java/com/huawei/browsergateway/common/utils/UserIdUtilTest.java`
- `src/test/java/com/huawei/browsergateway/entity/browser/BrowserStateMachineTest.java`

### 11.2 参考文档
- JUnit 5用户指南：https://junit.org/junit5/docs/current/user-guide/
- Mockito文档：https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html
- 决策表测试方法：软件测试技术相关教材


